<html>
<head>
<title>Super Csv - A super CSV reader/writer...</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta http-equiv="Content-Language" content="en-us">
<meta name="description" content="super CSV the best fast flexible CSV reader writer verifier verify read CSV, Write CSV, free">
<meta name="keywords" content="csv, cvs, parser, reader, writer, free, open source, read, write">
<meta name="author" content="Kasper B. Graversen">
<meta name="distribution" content="Global">
<meta name="language" content="en-uk">
<meta name="copyright" content="2006-2007 Kasper B. Graversen">

<style type="text/css">
body {
    border:0px none;
    MARGIN: 0px;
    VERTICAL-ALIGN: middle;
    background: url('img/bg.gif');
}
#content {
    color: #000000;
    font-weight: normal;
    font-size: 16px;
    font-family: Verdana, Arial, Helvetica, sans-serif;
    border: 33px;
    margin: 22px;
}

#header {
    color: 94B823;
    font-size: 72pt;
    font-family: Verdana, Arial, Helvetica, sans-serif;
    border: 1px;
    text-align: center;
    margin-top: 1cm;
}

#header links{
    color: 94B823;
    font-size: 8pt;
    font-family: Verdana, Arial, Helvetica, sans-serif;
    border: 1px;
    text-align: center;
    margin-top: 1cm;
}

#content h1 {
    color: #49586A;
    font-size: 28pt;
    font-family: Verdana, Arial, Helvetica, sans-serif;
    margin-top: 2.5cm;
}
#content h2 {
    margin-top: 1cm;
}

#content pre {
    background-color: #dddddd;
}
#content li {
    margin-bottom: 2mm;
}
#content td {
    color: #000000;
    font-weight: normal;
    font-size: 16px;
    font-family: Verdana, Arial, Helvetica, sans-serif;
}
#content th {
    text-align: left;
}
</style>
</head>
<body bgcolor="#cccccc">

<table width="100%" border="0" cellpadding="0" cellspacing="1">
<tr>
<td>&nbsp;</td>
<td valign="top" width="74" background="img/bgsideleft.gif">&nbsp;</td>
<td valign="top" width="70%" bgcolor="#FFFFFF">

<div id="header">Super CSV</div>
<div style="text-align: center;">by Kasper B. Graversen, 2006-2007<p>
<div style="links">
<a href="#motivation">Motivation</a> |
 <a href="#price">Pricing &amp; license</a> |
 <a href="#usage">Usage/Javadoc</a> |
 <a href="#codeExamples">Code examples</a> |
 <a href="#downloads">Downloads</a> |
 <a href="#csvSpecification">CSV specification</a>
</div>
</div>
<div id="content">

<a name="motivation">
<h1>Motivation</h1>
The main motivation for Super Csv is to create the <b>best</b> CSV package for processing CSV files.
Super Csv's unique features raises the bar and sets a new standard for CSV packages. Super Csv is designed around solid Object-oriented principles,
and thus aims to leverage your Object-oriented code, making it easier to write and maintain.
<p>
If you are unsure about what the CSV format is, please read my specification which covers my understanding of the concept:
<a href="#csvSpecification">The CSV format specification</a>.
<p>
Super Csv offers the following features not found together in other CSV packages

<ul>
<li>The ability to read/write POJO beans, Maps and String lists.</li>
<li>The ability to easily convert input/output to integers, dates, trimming strings, etc...</li>
<li>The ability to easily verify data conforms to some specification, such as number ranges, string sizes, uniqueness and even optional columns.</li>
<li>The ability to read/write data from anywhere in any encoding. As long as you provide a <tt>Reader</tt> or a <tt>Writer</tt>.
<li>Support for Windows, MAC and Linux line breaks.</li>
<li>Configurable separation character, espace character end end of line character (for writing files)</li>
<li>Correctly handling of characters such as <tt>"</tt> and <tt>,</tt></li>
<li>Operates on streams rather than filenames, enabling you to read/write CSV files e.g. over a network connection.</li>
</ul>

When combined, these features enables you to express clear and robust code for handling CSV files.
<p>
My years in industry dealing with  CSV files (among other things ;-), has enabled me to identify a number of limitations with existing CSV packages.
These limitations led me to write SuperCsv.
My main critisism of existing CSV packages is that reading and writing takes outset in operating on lists of strings.
What you really needed is the ability
to operate on a fan of different types of objects. Moreover, often you need to restrict input/output data such as minimum
and maximum sizes, or numeric ranges. Or maybe you are reading image names, and want to ensure you do not read names
contain the characters ":", " ", "/", "^", "%". SuperCSV deals with all these and many other issues. And should you have a constraint
not readily expressible in the package, new cellprocessors can easily be constructed.
<p>
The underlying implementation of Super Csv has been written in an extendible fashion, hence new readers/writters and cell processors can easily be supported.
The IoC (Inversion of Control) implementation patterns has been enforced, eradicating long-lived mistakes such as using
filenames as arguments rather than <tt>Reader</tt> and <tt>Writer</tt> objects. Design patterns such as "Chain of responsibility",
"The Null object pattern" can also be found in the code. Feel free to have a look.





<a name="price">
<h1>Price and license</h1>
Super Csv is Copyright 2007, Kasper B. Graversen
<P>
 <div style="margin-left: 1cm;">
 Licensed under the Apache License, Version 2.0 (the "License");<br>
 you may not use this file except in compliance with the License. <br>
 You may obtain a copy of the License at<br>
 <a href="http://www.apache.org/licenses/LICENSE-2.0">http://www.apache.org/licenses/LICENSE-2.0</a>
 <p>
 Unless required by applicable law or agreed to in writing, software<br>
 distributed under the License is distributed on an "AS IS" BASIS,<br>
 WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. <br>
 See the License for the specific language governing permissions and<br>
 limitations under the License.
 </div>
<p>

<table border="0">
<tr><td>
The Apache license allows using this product in open source as well as commercial applications.
If you or your company benefit from using Super Csv, please consider supporting the project by clicking the donate button.
A Percentage of all donations will be given back to the open source community (The Apache Foundation).</a>
<p>
If you as a company want the added security of paid support, we can arrange yearly subscriptions based on your needs.
Contact me for more information and pricing.
</td>
<td valign="top">
<a href="http://sourceforge.net/donate/index.php?group_id=201724"><img src="http://images.sourceforge.net/images/project-support.jpg" width="88" height="32" border="0" alt="Support This Project" />
</td>
</tr>
</table>


<a name="usage">
<a name="usage"/>
<h1>Using Super Csv</h1>

<h2>Dependencies</h2>
Super Csv requires JDK >= 1.5

<h2>Javadocs</h2>
Can be found here <a href="javadoc/index.html">Super Csv javadoc</a>



<h2>Test coverage</h2>
Super Csv is quite heavily tested - more than 98 Junit tests are guarding the behavior with a coverage > 95%.
While the tests are no guarantee, we hope most bugs have been eliminated. Here you can browse the code annotated with its test coverage:
<a href="emmareports/index.html">test coverage reports</a>.
Please feel free to submit any tests you find missing.


<h2>Speed indications</h2>
Speed is a relative thing, depending on the underlying hardware, the current load of the system etc. We compare SuperCSV's speed relative to
reading a file line by line and doing a <tt>split(",")</tt> on each line. While this comparison is not completely sound as a simple split does not
 encompass the complexities of CSV parsing it indicates the overhead of CSV procesing.
<p>
<table cellspacing="8">
<tr><th>Method</th><th>Relative speed</th><th>Average execution time</th></tr>
<tr><td>split()</td><td>100,00%</td><td>0,37</td></tr>
<tr><td>ListReader</td><td>338,92%</td><td>1,24</td></tr>
<tr><td>MapReader</td><td>424,24%</td><td>1,55</td></tr>
<tr><td>BeanReader</td><td>481,00%</td><td>1,76</td></tr>
<tr><td>BeanReader (full)</td><td>1003,66%</td><td>3,68</td></tr>
</table>
<p>
The test implementation can be found in class <tt>ReadingSpeedTest.java</tt> in the source folder. The test generate a csv file consisting of
 250.000 lines each with 6 columns of random size representing numbers, names and dates. The generated file is approximately 7.6 MB.
The file is then read 5 times for each reading strategy used. The tests were conducted
a slow 1800 Dell with 500 MB ram (of which 472 were in use upon testing).
<p>
The conclusion of the tests are that SuperCSV is only 3-5 times slower than a native read with a simple (insufficient) processing of data.
Processing 1/4 of a million lines
takes less than 2 seconds (the BeanReader). The two seconds encompasses reading the file, parsing the lines, instantiating a bean instance
and populate the fields (as strings) using the bean's set-methods.  The last row in the table (BeanReader full) is special in the sense,
that on top of reading lines, creating objects and populating fields, it converts two columns on each lines into long's and one column into a date.
<p>
Putting these figures into perspective, I once was hired to fix a business application that spent 16 hours processing a CSV file of around 50.000 lines.
So if your application is running slow, I dare say that it is unlikely due to using SuperCSV!



<h2>Overall usage explained</h2>
When using Super Csv you have to make five decisions
<ol>
<li>Will I read or write? Depending on choice use a reader or a writer</li>

<li>What data structure will I read/write the data into/from.
For example when reading, reading into a  bean use <a href="javadoc/org/supercsv/io/CsvBeanReader.html">CSVBeanReader</a>,
read into a map use <a href="javadoc/org/supercsv/io/CsvMapReader.html">CSVMapReader</a>
or a String list use <a href="javadoc/org/supercsv/io/ICsvListReader.html">CSVListReader</a></li>

<li>If reading into maps or beans, either define a list of column names or utilize an existing header from the CSV file (if any).
Use <tt>getCSVHeader()</tt> to easily retrieve the header</li>

<li>Decide on what conversions and constraints you want for each column.
See <a href="javadoc/org/supercsv/cellprocessor/package-summary.html">processors</a>
and <a href="javadoc/org/supercsv/cellprocessor/constraint/package-summary.html">constraints</a>.</li>

<li>Specify preferences for separation character, newline character, etc. See <a href="javadoc/org/Super Csv/prefs/package-summary.html">preferences</a>.</ul>
</ol>










<a name="codeExamples">
<h1>Code examples</h1>


<h2>Code example: Read a CSV file using its header</h2>

To read lines from a file into an object, assume you have the bean class

<pre>
public class UserBean {
    String username, password, street, town;
    int zip;

    public String getPassword() { return password; }
    public String getStreet() { return street; }
    public String getTown() { return town; }
    public String getUsername() { return username; }
    public int getZip() { return zip; }
    public void setPassword(String password) { this.password = password; }
    public void setStreet(String street) { this.street = street; }
    public void setTown(String town) { this.town = town; }
    public void setUsername(String username) { this.username = username; }
    public void setZip(int zip) { this.zip = zip; }
}
</pre>

and that you have a CSV file with a header. Let's assume the following content

<pre>
username, password,   date,        zip,  town
Klaus,    qwexyKiks,  17/1/2007,   1111, New York
Oufu,     bobilop,    10/10/2007,  4555, New York
</pre>

You can then create an instance of the <tt>UserBean</tt> and populate it with values from the second line of the file with the following code

<pre>
import java.io.*;
import org.supercsv.cellprocessor.*;
import org.supercsv.cellprocessor.constraint.*;
import org.supercsv.io.ICsvBeanReader;
import org.supercsv.io.CsvBeanReader;
import org.supercsv.prefs.CsvPreference;

class ReadingObjects {
  public static void main(String[] args) throws Exception{
    ICsvBeanReader inFile = new CsvBeanReader(new FileReader("foo.csv"), CsvPreference.EXCEL_PREFERENCE);
    try {
      final String[] header = inFile.getCSVHeader(true);
      UserBean user = inFile.read(UserBean.class, header, processors);
    } finally {
      inFile.close();
    }
  }
}
</pre>

What is left to define is <tt>processors</tt>. Despite its condensed form, the cell processors captures quite expressive semantics.
Each position in the <tt>CellProcessor</tt> array corresponds to a
column in the CSV file. If a cell in the array has the value <tt>null</tt>, the column will be read but not processed.
Each processor can be <b>nested</b>. This means that processors and constraints can be freely combined in any number as seen below with the
<tt>new Unique(new StrMinMax())</tt>. This is a very expressive so spend some time dwelling on what you can do with the processors.
<p>
One definition could be

<pre>
final CellProcessor[] processors = new CellProcessor[] {
    new Unique(new StrMinMax(5, 20)),
    new StrMinMax(8, 35),
    new ParseDate("dd/MM/yyyy"),
    new Optional(new ParseInt()),
    null
};
</pre>

The above definition captures the following semantics:

<ul>
<li>Read column 1 as a String and ensure each value has a length between 5-20. Further more, insure that values in this column are all unique.</li>
<li>Read column 2 as a String and ensure each value has a length between 8-35.</li>
<li>Read column 3 as a date of the format day/month/year.</li>
<li>Read column 4 as an integer. But only do so if something is actually defined in the column.</li>
<li>Read column 5 as is (a String). Don't process or constrain its values.</li>
</ul>

Notice how Super Csv utilizes the fact that the file had a header. If your files are without headers,
you can easily create the missing information by means of a string array such as

<pre>
final String[] header = new String[] { "username", "password", "date", "zip", "town"};
</pre>

If we want to omit a column when reading/writing, simply set the header array element to <tt>null</tt>. This is somewhat analogous to
setting a processor array element to <tt>null</tt> which disables processing of that column.








<h2>Code example: Write a file with a header</h2>
Writing a file is as easy as reading one. You decide on the column format and start writing. You can still enjoy the cell processor
functionality, however, you will most likely only use the constraint parts. Any value is being written to the output stream using
the <tt>toString()</tt> method on each object, thus reducing the need for the cell processors that convert data.

<pre>
import java.util.HashMap;
import org.supercsv.io.*;
import org.supercsv.prefs.CsvPreference;

class WritingMaps {
  main(String[] args) throws Exception {
    ICsvMapWriter writer = new CsvMapWriter(new FileWriter(...), CsvPreference.EXCEL_PREFERENCE);
    try {
      final String[] header = new String[] { "name", "city", "zip" };
      <b>// set up some data to write</b>
      final HashMap&lt;String, ? super Object> data1 = new HashMap&lt;String, Object>();
      data1.put(header[0], "Karl");
      data1.put(header[1], "Tent city");
      data1.put(header[2], 5565);
      final HashMap&lt;String, ? super Object> data2 = new HashMap&lt;String, Object>();
      data2.put(header[0], "Banjo");
      data2.put(header[1], "River side");
      data2.put(header[2], 5551);
      <b>// the actual writing</b>
      writer.writeHeader(header);
      writer.write(data1, header);
      writer.write(data2, header);
    } finally {
      writer.close();
    }
  }
}
</pre>

Notice, that even though we are writing numbers, we do not need the cell processor, as the numbers <tt>toString()</tt> is called
prior to writing. We could have added a cell processor to ensure that the numbers were above a certain threshold, and the string
lengths were &gt; 0 if we wanted.





<h2>Extending SuperCSV</h2>
You can easily extend Super CSV if you need to. Just implement the interface <tt>CellProcessor</tt> and you are set. Most of the
existing processors are around 10 lines of code. Let's investigate the implementations by looking at a cellprocessor which reads
 a column and converts it into a <tt>Long</tt> object. The cell processors are build around the patters "null object pattern" and
 "chain of responsibility" hence all the infrastructure is set up outset the processors.

 <pre>
 public class ParseLong extends CellProcessorAdaptor {
    <b>/** important to invoke super */</b>
    public ParseLong() {
        super();
    }

    <b>/** important to invoke super */</b>
    public ParseLong(final LongCellProcessor next) {
        super(next);
    }
    <b>/** simplife conversion of column to Long */</b>
    public Object execute(final Object value, final CSVContext context) throws NumberFormatException {
        final Long result = Long.parseLong((String) value);
        return next.execute(result, context);
    }
}
 </pre>

All the magic is taking place in the <tt>execute()</tt> method. It really need no further explaining.







<a name="downloads">
<h1>Downloads & Versions</h1>

<table cellspacing="8">
<tr><th>Version</th><th>Changes</th></tr>
<tr><td valign="top">1.0</td><td>Initial release</td></tr>
<tr><td valign="top">1.01</td><td>Small bugfixes.
<ul>
<li>Inherited properties are now supported by the bean reader/writer</li>
<li>Jar file is now compiled for JDK 5.</li>
</ul>
</td></tr>
<tr><td valign="top">1.02</td><td>Small bugfixes.
<ul>
<li>Empty cells with value <tt>""</tt> was mistakenly interpreted as an escaped quoted char rather than the empty line</li>
<li>No longer removes trailing spaces inside quotes so <tt>" hello "</tt> is read as <tt>" hello "</tt> rather than <tt>" hello"</tt></li>
<li>Renamed the cellprocessor <tt>MagicToken</tt> to <tt>Token</tt>
<li>TABs are not regarded as whitespace anymore</li>
</ul>
</td></tr>
</table>
<p>
The download section can be found at <a href="http://sourceforge.net/projects/supercsv">the Super Csv source forge download page</a>
<p>
Ideas for the future

<ul>
<li>Comment character support (is anyone using this anyway??)</li>
<li>More cell processors</li>
<li>Batch reading and writing, delaying errors</li>
</ul>









<a name="csvSpecification">
<h1>The CSV format specification</h1>
The following is my understanding of the CSV formats definition (and correspondingly what is supported in Super Csv.
<p>
First, a formal EBNF (extended Bachus-Naur Form) where "<tt>,</tt>" denotes the separation character.
See <a href="http://en.wikipedia.org/wiki/Backus-Naur_form">Wikipedia/BNF</a> and
<a href="http://en.wikipedia.org/wiki/Extended_Backus-Naur_form">Wikipedia/EBNF</a>
for further information on (E)BNF.
</p>
<pre>
CSV file
--------
file         ::= [ header ] { line }
header       ::= [ { entry separator } entry ] newline
line         ::= [ { entry separator } entry ] newline
entry        ::= character+ | { character* " separator " } | " entry newline entry "
newline      ::= \n
separator    ::= ,
character    ::= a|b|..|A|B|..|0|1|..
escapedQuote ::= ""
</pre>

Or more informally..

<ul>
<li>Entities are separated by new line characters</li>
<li>Entries of an entity are separated by a separation character, often a comma (",") excluding the the last element of a line</li>
<li>An entry may contain the separation character in which case that character is enclosed in quotes</li>
<li>An entry may contain newlines in which case the whole entry is enclosed in quotation marks</li>
<li>The first line of the file may contain the header descriptions for the columns of the file,
 and may be ignored (or as in the case of Super Csv be utilized when reading data into maps or beans.</li>
<li>Any white-spaces at the start of a line, just after the separation character, just before a separation character,
 or just before a newline character is ignored.
 </li>
 <li>An escaped quote is two consecutive quote characters. The only exception to this rule is when the first character in
 a cell is a quote it always denotes a quote for the form <tt>" entry newline entry "</tt>. Hence the entry <tt>""</tt>
 (double quote in a cell) denotes the empty string, whereas the input <tt>""""</tt> denotes the string <tt>"</tt>
 </li>
</ul>



</div>
</td>
<td valign="top" width="36" background="img/bgsideright.gif">&nbsp;</td>
<td valign="top">&nbsp;
<script type="text/javascript">
            google_ad_client = "pub-1222515461989279";
            google_alternate_color = "8B725A";
            google_ad_width = 160;
            google_ad_height = 600;
            google_ad_format = "160x600_as";
            google_ad_type = "text_image";
            google_ad_channel ="";
            google_color_border = "8B725A";
            google_color_bg = "FFFFFF";
            google_color_link = "333399";
            google_color_url = "008000";
            google_color_text = "000000";
            </script>
<br><br>
<script type="text/javascript" src="http://pagead2.googlesyndication.com/pagead/show_ads.js"/>
<br><br>
<script type="text/javascript">
            google_ad_client = "pub-1222515461989279";
            google_alternate_color = "8B725A";
            google_ad_width = 160;
            google_ad_height = 600;
            google_ad_format = "160x600_as";
            google_ad_type = "text_image";
            google_ad_channel ="";
            google_color_border = "8B725A";
            google_color_bg = "FFFFFF";
            google_color_link = "333399";
            google_color_url = "008000";
            google_color_text = "000000";
            </script>
<br><br>
<script type="text/javascript" src="http://pagead2.googlesyndication.com/pagead/show_ads.js"/>
<br><br>
<script type="text/javascript">
            google_ad_client = "pub-1222515461989279";
            google_alternate_color = "8B725A";
            google_ad_width = 160;
            google_ad_height = 600;
            google_ad_format = "160x600_as";
            google_ad_type = "text_image";
            google_ad_channel ="";
            google_color_border = "8B725A";
            google_color_bg = "FFFFFF";
            google_color_link = "333399";
            google_color_url = "008000";
            google_color_text = "000000";
            </script>
<br><br>
<script type="text/javascript" src="http://pagead2.googlesyndication.com/pagead/show_ads.js"/>
</td>
</tr>
</table>

<script src="http://www.google-analytics.com/urchin.js" type="text/javascript">
</script>
<script type="text/javascript">
_uacct = "UA-2431107-1";
urchinTracker();
</script>
</body>
</html>