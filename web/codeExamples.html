<html>
<head>
<title>Super Csv - A super CSV reader/writer...</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta http-equiv="Content-Language" content="en-us">
<meta name="description" content="super CSV the best fast flexible CSV reader writer verifier verify read CSV, Write CSV, free">
<meta name="keywords" content="csv, cvs, parser, reader, writer, free, open source, read, write">
<meta name="author" content="Kasper B. Graversen">
<meta name="distribution" content="Global">
<meta name="language" content="en-uk">
<meta name="copyright" content="2006-2007 Kasper B. Graversen">

<!-- google pretty print - start -->
<link href="prettify.css" type="text/css" rel="stylesheet" />
<script type="text/javascript" src="prettify.js"></script>
<!-- google pretty print - end -->

<link href="supercsv.css" type="text/css" rel="stylesheet" />
</head>
<body bgcolor="#cccccc" onload="prettyPrint()">
<table width="100%" border="0" cellpadding="0" cellspacing="1">
<tr>
<td>&nbsp;</td>
<td valign="top" width="74" background="img/bgsideleft.gif">&nbsp;</td>
<td valign="top" width="70%" bgcolor="#FFFFFF">

<div id="header">Super CSV</div>
<div style="text-align: center;">by Kasper B. Graversen, 2006-2007<p>
<div style="links">
 <a href="motivation.html">Motivation</a> |
 <a href="price.html">Pricing &amp; License</a> |
 <a href="usage.html">Usage/Javadoc</a> |
 <a href="codeExamples.html">Code examples</a> |
 <a href="downloads.html">Downloads</a> |
 <a href="csvSpecification.html">CSV Specification</a>
</div>
</div>
<div id="content">
<h1>Code examples</h1>


<h2>Code example: Read a CSV file using its header</h2>

To read lines from a file into an object, assume you have the bean class

<pre class="prettyprint">
public class UserBean {
    String username, password, street, town;
    int zip;

    public String getPassword() { return password; }
    public String getStreet() { return street; }
    public String getTown() { return town; }
    public String getUsername() { return username; }
    public int getZip() { return zip; }
    public void setPassword(String password) { this.password = password; }
    public void setStreet(String street) { this.street = street; }
    public void setTown(String town) { this.town = town; }
    public void setUsername(String username) { this.username = username; }
    public void setZip(int zip) { this.zip = zip; }
}
</pre>

and that you have a CSV file with a header. Let's assume the following content

<pre class="prettyprint">
username, password,   date,        zip,  town
Klaus,    qwexyKiks,  17/1/2007,   1111, New York
Oufu,     bobilop,    10/10/2007,  4555, New York
</pre>

You can then create an instance of the <tt>UserBean</tt> and populate it with values from the second line of the file with the following code

<pre class="prettyprint">
import java.io.*;
import org.supercsv.cellprocessor.*;
import org.supercsv.cellprocessor.constraint.*;
import org.supercsv.io.ICsvBeanReader;
import org.supercsv.io.CsvBeanReader;
import org.supercsv.prefs.CsvPreference;

class ReadingObjects {
  public static void main(String[] args) throws Exception{
    ICsvBeanReader inFile = new CsvBeanReader(new FileReader("foo.csv"), CsvPreference.EXCEL_PREFERENCE);
    try {
      final String[] header = inFile.getCSVHeader(true);
      UserBean user;
      while( (user = inFile.read(UserBean.class, header, processors) != null) {
        System.out.println(user.getZip());
      }
    } finally {
      inFile.close();
    }
  }
}
</pre>

What is left to define is <tt>processors</tt>. Despite its condensed form, the cell processors captures quite expressive semantics.
Each position in the <tt>CellProcessor</tt> array corresponds to a
column in the CSV file. If a cell in the array has the value <tt>null</tt>, the column will be read but not processed.
Each processor can be <b>nested</b>. This means that processors and constraints can be freely combined in any number as seen below with the
<tt>new Unique(new StrMinMax())</tt>. This is a very expressive so spend some time dwelling on what you can do with the processors.
<p>
One definition could be

<pre class="prettyprint">
final CellProcessor[] processors = new CellProcessor[] {
    new Unique(new StrMinMax(5, 20)),
    new StrMinMax(8, 35),
    new ParseDate("dd/MM/yyyy"),
    new Optional(new ParseInt()),
    null
};
</pre>

The above definition captures the following semantics:

<ul>
<li>Read column 1 as a String and ensure each value has a length between 5-20. Further more, insure that values in this column are all unique.</li>
<li>Read column 2 as a String and ensure each value has a length between 8-35.</li>
<li>Read column 3 as a date of the format day/month/year.</li>
<li>Read column 4 as an integer. But only do so if something is actually defined in the column.</li>
<li>Read column 5 as is (a String). Don't process or constrain its values.</li>
</ul>

Notice how Super Csv utilizes the fact that the file had a header. If your files are without headers,
you can easily create the missing information by means of a string array such as

<pre class="prettyprint">
final String[] header = new String[] { "username", "password", "date", "zip", "town"};
</pre>

If we want to omit a column when reading/writing, simply set the header array element to <tt>null</tt>. This is somewhat analogous to
setting a processor array element to <tt>null</tt> which disables processing of that column.








<h2>Code example: Write a file with a header</h2>
Writing a file is as easy as reading one. You decide on the column format and start writing. You can still enjoy the cell processor
functionality, however, you will most likely only use the constraint parts. Any value is being written to the output stream using
the <tt>toString()</tt> method on each object, thus reducing the need for the cell processors that convert data.

<pre class="prettyprint">
import java.util.HashMap;
import org.supercsv.io.*;
import org.supercsv.prefs.CsvPreference;

class WritingMaps {
  main(String[] args) throws Exception {
    ICsvMapWriter writer = new CsvMapWriter(new FileWriter(...), CsvPreference.EXCEL_PREFERENCE);
    try {
      final String[] header = new String[] { "name", "city", "zip" };
      // set up some data to write
      final HashMap&lt;String, ? super Object> data1 = new HashMap&lt;String, Object>();
      data1.put(header[0], "Karl");
      data1.put(header[1], "Tent city");
      data1.put(header[2], 5565);
      final HashMap&lt;String, ? super Object> data2 = new HashMap&lt;String, Object>();
      data2.put(header[0], "Banjo");
      data2.put(header[1], "River side");
      data2.put(header[2], 5551);
      // the actual writing
      writer.writeHeader(header);
      writer.write(data1, header);
      writer.write(data2, header);
    } finally {
      writer.close();
    }
  }
}
</pre>

Notice, that even though we are writing numbers, we do not need the cell processor, as the numbers <tt>toString()</tt> is called
prior to writing. We could have added a cell processor to ensure that the numbers were above a certain threshold, and the string
lengths were &gt; 0 if we wanted.





<h2>Extending SuperCSV</h2>
You can easily extend Super CSV if you need to. Just implement the interface <tt>CellProcessor</tt> and you are set. Most of the
existing processors are around 10 lines of code. Let's investigate the implementations by looking at a cellprocessor which reads
 a column and converts it into a <tt>Long</tt> object. The cell processors are build around the patters "null object pattern" and
 "chain of responsibility" hence all the infrastructure is set up outset the processors.

 <pre class="prettyprint">
 public class ParseLong extends CellProcessorAdaptor {
    <b>/** important to invoke super */</b>
    public ParseLong() {
        super();
    }

    <b>/** important to invoke super */</b>
    public ParseLong(final LongCellProcessor next) {
        super(next);
    }
    <b>/** simplife conversion of column to Long */</b>
    public Object execute(final Object value, final CSVContext context) throws NumberFormatException {
        final Long result = Long.parseLong((String) value);
        return next.execute(result, context);
    }
}
 </pre>

All the magic is taking place in the <tt>execute()</tt> method. It really need no further explaining.










</div>
</td>
<td valign="top" width="36" background="img/bgsideright.gif">&nbsp;</td>
<td valign="top">&nbsp;
<script type="text/javascript">
            google_ad_client = "pub-1222515461989279";
            google_alternate_color = "8B725A";
            google_ad_width = 160;
            google_ad_height = 600;
            google_ad_format = "160x600_as";
            google_ad_type = "text_image";
            google_ad_channel ="";
            google_color_border = "8B725A";
            google_color_bg = "FFFFFF";
            google_color_link = "333399";
            google_color_url = "008000";
            google_color_text = "000000";
            </script>
<br><br>
<script type="text/javascript" src="http://pagead2.googlesyndication.com/pagead/show_ads.js"/>
<br><br>
<script type="text/javascript">
            google_ad_client = "pub-1222515461989279";
            google_alternate_color = "8B725A";
            google_ad_width = 160;
            google_ad_height = 600;
            google_ad_format = "160x600_as";
            google_ad_type = "text_image";
            google_ad_channel ="";
            google_color_border = "8B725A";
            google_color_bg = "FFFFFF";
            google_color_link = "333399";
            google_color_url = "008000";
            google_color_text = "000000";
            </script>
<br><br>
<script type="text/javascript" src="http://pagead2.googlesyndication.com/pagead/show_ads.js"/>
<br><br>
<script type="text/javascript">
            google_ad_client = "pub-1222515461989279";
            google_alternate_color = "8B725A";
            google_ad_width = 160;
            google_ad_height = 600;
            google_ad_format = "160x600_as";
            google_ad_type = "text_image";
            google_ad_channel ="";
            google_color_border = "8B725A";
            google_color_bg = "FFFFFF";
            google_color_link = "333399";
            google_color_url = "008000";
            google_color_text = "000000";
            </script>
<br><br>
<script type="text/javascript" src="http://pagead2.googlesyndication.com/pagead/show_ads.js"/>
</td>
</tr>
</table>

<script src="http://www.google-analytics.com/urchin.js" type="text/javascript">
</script>
<script type="text/javascript">
_uacct = "UA-2431107-1";
urchinTracker();
</script>
</body>
</html>